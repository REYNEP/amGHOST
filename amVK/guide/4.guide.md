---
export_on_save:
  prince: true
---
@import "amVK_DocsClass1.less"





<div align=center>

![svg1](./4.guide.title.svg)

</div>

## Chapter 0: Prerequisites
#### 1. What is `Vulkan`? Why `Vulkan`?
1. Read the `1. Introduction` part from here only üòä
    1. https://paminerva.github.io/docs/LearnVulkan/01.A-Hello-Window
    2. [TODO:-] Convert (above page) to PDF and add a link to that
2. Alternatively:- you can give this page a try too:- https://vkdoc.net/chapters/fundamentals
3. Why should **_'you'_** learn/use `Vulkan`?
    1. Faster
    2. More Control
    3. Lower Level API
4. Why is this Important?
    1. Well if you are planning on becoming a game dev, then yeah. Otherwise OpenGL is kinda enough.
5. When will I need `vulkan`?
    1. kind of never, unless you've grown tired of OpenGL
6. How does `vulkan` work?
    - Rest of the document is dedicated to answer this question üòä
</br>

#### 2. grab `vulkan-sdk`, `cmake`, `amGHOST`
1. https://vulkan.lunarg.com/sdk/home
    - make sure `VULKAN_SDK` & `VK_SDK_PATH` environment variables are set
    - restart vscode after installing
2. https://cmake.org/download/
    - [optional] https://enccs.github.io/intro-cmake/hello-cmake/
    - [optional] OR: Watch 6/7 videos from this playlist:- https://www.youtube.com/playlist?list=PLK6MXr8gasrGmIiSuVQXpfFuE1uPT615s
    - restart vscode after installing
3. if you don't have `vscode` & `C++ Compiler` --> see [4.guide.vscode.md](./4.guide.vscode.md)  
4. `git clone -b win32-intro https://github.com/REYNEP/amGHOST`
    - Open it with VSCode
    - `F1` --> `CMake: Configure`
    - `F1` --> `CMake: Build`
    - `F1` --> `CMake: Install` --> `.insall` dir
    - check's _**amGHOST's Usage Example**_ inside `amGHOST/README.md`
    - `Option 1`:- use `cmake` for your project too.... using `add_subdirectory(amGHOST)`
    - `Option 2`:- use `libamGHOST.lib` after installing & `#include amGHOST/<header>`
    - just copy paste _**amGHOST's Usage Example**_ into a `main.cpp` for your program
        - now you shall have a OS-Window üòä







<div style="page-break-before: always;"></div>
</br>
</br>
</br>
</br>
</br>

<div align=center>

![svg2](./4.guide.title2.svg)
![img1](./images/Khronos-Press-Update-SIGGRAPH-Jul19-2019-page36-1.png)

</div>

## Chapter 1: `VkInstance`
#### 1. `VkApplicationInfo`
- https://vkdoc.net/man/VkApplicationInfo
    - do remember to check the `Valid Usage` section üòâ
- yes, what are you waiting for, go go, shooo....
    1. `#include <vulkan/vulkan.h>`
    2. take an instance of that `Struct` -> Fill it up [üòâ][have the vkdoc.net as assist]
- ##### REY Docs
    - `VkApplicationInfo` -> holds `name` and `version`, also the `lowest Vulkan API version` Your APP **_"can run"_** on. [*clarification needed:- lowest or highest]
    - Also, we can set the `name` and `version` of the `engine` (if any) used to create Your APP. This can help `vulkan driver implementations` to perform ad-hoc optimizations.
        - e.g. like if a Triple-A [AAA] game used, for say, `Unreal Engine Version 4.1.smth` idk ü§∑‚Äç‚ôÄÔ∏è
    - REFs:- [1. minerva](https://paminerva.github.io/docs/LearnVulkan/01.A-Hello-Window)

<div style="page-break-before: always;"></div>

#### 2. `VkInstanceCreateInfo`
- https://vkdoc.net/man/VkInstanceCreateInfo
    - yeah, do remember to check the `Valid Usage` section üòâ
    - Don't hesitate about `EnabledLayer` & `EnabledExtensions` right now
        - come back and add them when you need to
- ##### REY Docs
    - Nothing that I need to add
    - Tho if this section gets big, I will create a separate `.md` file for that thingy

#### 3. `VkInstance m_instance = nullptr;`
- https://vkdoc.net/man/VkInstance
    - again.... yeah, do remember to check the `Valid Usage` section üòâ

#### 4. `vkCreateInstance(CI, &m_instance)`
- https://vkdoc.net/man/vkCreateInstance
    - `Valid Usage` section.... (yeah, everytime)

#### 5. Error Handling / Checking / Logging
- check out my [`amVK_log.hh`](./../amVK_log.hh)
    - uses [REY_LoggerNUtils](https://github.com/REYNEP/amGHOST) inside amGHOST
    - has a simple `stackTracer()` that i basically stripped from blender3D codebase ü•¥

#### 6. The Result
- Check out:- [4.guide.chapter1.hh](./examples/4.guide.chapter1.hh)















</br>
</br>
</br>
</br>
</br>
<div style="page-break-after: always;"></div>
<div align=center>

![img1](./images/Vulkanised-2023-Tutorial-PART1_Page12_REY.png)
Take a look into this awesome [slide](./Vulkanised-2023-Tutorial/Vulkanised-2023-Tutorial-PART1.pdf) from slide-26 onwards, to understand what each of steps _"feel like"/mean/"how to imagine them"_.
*slide = [Vulkanised 2023 Tutorial Part 1](https://www.khronos.org/assets/uploads/developers/presentations/Vulkanised-2023-Tutorial-PART1.pdf)

</div>

## Chapter 2: `VkDevice`
#### 1. `vkEnumeratePhysicalDevices(m_instance, &m_deviceCount, nullptr)`
- https://vkdoc.net/man/vkEnumeratePhysicalDevices
- ##### REY Docs
    ```cpp
    uint32_t deviceCount = 0;     
        // [implicit valid usage]:- must be 0 [if 3rd-param = nullptr]
        vkEnumeratePhysicalDevices(m_instance, &deviceCount, nullptr);
            // it's kinda like the function is 'output-ing into' deviceCount

    std::vector<VkPhysicalDevice> HardwareGPU_List(gpuCount);
        // best to save this as a class member variable
        vkEnumeratePhysicalDevices(m_instance, &deviceCount, HardwareGPU_List.data());
            // note: it does return     VkResult return_code
    ```
- Visualization / [See it] / JSON Printing:- [4.guide.chapter2.1.json.hh](./examples/4.guide.chapter2.1.json.hh)
- So far, The result:- [4.guide.chapter2.1.midway.hh](./examples/4.guide.chapter2.1.midway.hh)

#### 2. `vkCreateDevice()`
- https://vkdoc.net/man/vkCreateDevice
    - `param pAllocator` -> **"Chapter ZZZ"**
- ##### REY DOCs
    - we are not gonna call the `vkCreateDevice()` yeeeet....
        - but, yes, we've already made the class container around it üòÖ
        - we'll call this functiion in `Chapter2.9.`
    - but we did need to know first about `vkCreateDevice()`
        - because, the idea is, our sole task is to _**fill it up step by step**_

#### 3. `VkDeviceCreateInfo`
- https://vkdoc.net/man/VkDeviceCreateInfo
    - `.LayerInfo` -> Deprecated
    - `.ExtensionInfo` -> **"Chapter ZZZ"**
    - `.pQueueCreateInfos` -> next part 
        - So far, The result:- [4.guide.chapter2.3.midway.hh](./examples/4.guide.chapter2.3.midway.hh)
- ##### REY Docs
    - `.pQueueCreateInfos` -> yes, you 'can' mass multiple üòâ
    - Sometimes there will be `.zzzCreateInfoCount` & `.pZZZCreateInfos` 
        - So you could like pass in an array/vector
        - You will see this in lots of other places

#### 4. `VkDeviceQueueCreateInfo` - *'The Real Deal'*
- https://vkdoc.net/man/VkDeviceQueueCreateInfo
    - `.queueFamilyIndex` -> next 3 subchapters
        - So far, The result:- [4.guide.chapter2.4.midway.hh](./examples/4.guide.chapter2.4.midway.hh)
- ##### REY Docs:- Support for multiple QCI
    - `.pQueuePriorities` -> yes, this can be multiple "Priorities" ü•¥ [idk yet why tho]
    ```cpp
    /* ============ REY_LoggerNUtils::REY_Utils.hh ============ */
    REY_ArrayDYN<VkDeviceQueueCreateInfo> Array = REY_ArrayDYN<VkDeviceQueueCreateInfo>(2);
        // allocate enough space for 2 elements
    REY_ARRAY_PUSH_BACK(Array) = this->Default_QCI;
    REY_ARRAY_PUSH_BACK(Array) =          Your_QCI;

    /* ============ std::vector ============ */
    std::vector<VkDeviceQueueCreateInfo> Array = std::vector<VkDeviceQueueCreateInfo>(2);
    Array.push_back(this->Default_QCI);
    Array.push_back(         Your_QCI)
    ```
- So far, The result:- [4.guide.chapter2.4.TheEnd.hh](./examples/4.guide.chapter2.4.TheEnd.hh)

#### 5. `vkGetPhysicalDeviceQueueFamilyProperties()`
- https://vkdoc.net/man/vkGetPhysicalDeviceQueueFamilyProperties
- ##### REY DOCS
    - a GPU can have _"multiple QueueFamilies"_
        - a `QueueFamily` might support `VK_QUEUE_GRAPHICS_BIT`
        - another `QueueFamily` might support `VK_QUEUE_COMPUTE_BIT`
        - another `QueueFamily` might support `VK_QUEUE_TRANSFER_BIT`
        - another `QueueFamily` might support `VK_QUEUE_VIDEO_ENCODE_BIT_KHR`
        - another `QueueFamily` might support a-mixture of multiple
        - talking about this in -> the next part [chapter2.6.]
    ```cpp
    static inline REY_Array<REY_Array<VkQueueFamilyProperties>>   s_HardwareGPU_QFamProps_List2D;
    #define amVK_2D_QFAM_PROPs                     amVK_Instance::s_HardwareGPU_QFamProps_List2D
        // "REY_LoggerNUtils/REY_Utils.hh" üòÑ

    static inline void GetPhysicalDeviceQueueFamilyProperties(void) {
        amVK_2D_QFAM_PROPs.reserve(amVK_GPU_List.n);            // malloc using "new" keyword
        for ( uint32_t k = 0;  k < amVK_GPU_List.n; k++ )       // for each GPU
        {
            REY_Array<VkQueueFamilyProperties> *k_QFamProps = &amVK_2D_QFAM_PROPs.data[k];

            uint32_t queueFamilyCount = 0;
                vkGetPhysicalDeviceQueueFamilyProperties(amVK_GPU_List[k], &queueFamilyCount, nullptr);

            k_QFamProps->n = queueFamilyCount;
            k_QFamProps->data = new VkQueueFamilyProperties[queueFamilyCount];
                vkGetPhysicalDeviceQueueFamilyProperties(amVK_GPU_List[k], &k_QFamProps->n, k_QFamProps->data);
        }
    }
    ```
- ##### Visualization / [See it] / JSON Printing:- [4.guide.chapter2.5.json.hh](./examples/4.guide.chapter2.5.json.hh)
    - Check the [3070 JSON by REY](./examples/4.guide.chapter2.5.data.json)
- ##### So far, The result:- [4.guide.chapter2.5.TheEnd.hh](./examples/4.guide.chapter2.5.TheEnd.hh)
    - Compare to -> [4.guide.chapter2.1.midway.hh](./examples/4.guide.chapter2.1.midway.hh)
        - `2DArray_QFAM_Props` part & below were added only compared to `Chapter2.1.`

#### 6. `VkQueueFamilyProperties`
- https://vkdoc.net/man/VkQueueFamilyProperties
- ##### REY DOCs
    - `.queueFlags` -> we are gonna choose a `QCI.queueFamilyIndex` based on these flags
        - primarily, for the least, we wanna choose a `QueueFamily` that supports `VK_QUEUE_GRAPHICS_BIT`
        - all kinds of amazing things can be done using 
            - `VK_QUEUE_COMPUTE_BIT`
            - `VK_QUEUE_TRANSFER_BIT`
            - `VK_QUEUE_VIDEO_ENCODE_BIT_KHR`
    - `.queueCount` -> yes there is a limit to 'how many `Queues` we are allowed to work with' ü•¥
    
#### 7. `VkDeviceQCI.queueFamilyIndex`
- `QCI => QueueCreateInfo` 
    - [VkDeviceQueueCreateInfo]
- ##### REY DOCs
    - `Task:-` is to choose a `QueueFamily` that supports `VK_QUEUE_GRAPHICS_BIT` üòâ
        - (if you've followed on so far -> this should be easy üòâ) 
    - Resolving all of this into `amVK_Device.hh`
        ```cpp
        void amVK_Device::Select_QFAM_GRAPHICS(void) {
            if (!amVK_Instance::called_GetPhysicalDeviceQueueFamilyProperties) {
                amVK_Instance::EnumeratePhysicalDevices();
            }

            if (!amVK_Instance::called_GetPhysicalDeviceQueueFamilyProperties) {
                amVK_Instance::GetPhysicalDeviceQueueFamilyProperties();
            }

            amVK_Instance::amVK_PhysicalDevice_Index index = amVK_HEART->GetARandomPhysicalDevice_amVK_Index();
            this->QCI.Default.queueFamilyIndex = amVK_Instance::ChooseAQueueFamily(VK_QUEUE_GRAPHICS_BIT, index);
        }
        ```

#### 8. back to `vkCreateDevice()` [finally calling it üòä]
- ##### REY DOCs
    ```cpp
    amVK_Device* D = new amVK_Device(amVK_HEART->GetARandomPhysicalDevice());
        // VkDeviceCreateInfo CI => Class Member
        // VkDeviceQueueCreateInfo QCI => Class Member
    D->Select_QFAM_GRAPHICS();
    D->CreateDevice();
    ```
    - Think of this as a PSeudoCode / or / check out my code if you wanna
    - `CreateInfo` => By default has initial values inside `amVK_Device`

#### 9. Organizing stuff into classes....
1. `amVK_Props.hh`
    1. `class amVK_Props`
        - `amVK_Instance::GetPhysicalDeviceQueueFamilyProperties()`
        - `amVK_Instance::EnumeratePhysicalDevices()`
        - & Everything related to those two + The Data + The Properties

#### 10. `vkGetPhysicalDeviceProperties()`
- for now we won't need, we will need in `ChapterXXX`
- https://vkdoc.net/man/vkGetPhysicalDeviceProperties
- `VkPhysicalDeviceProperties`:- https://vkdoc.net/man/VkPhysicalDeviceProperties
    - `.deviceType`:- https://vkdoc.net/man/VkPhysicalDeviceType
    - `.limits`:- save it for later üòâ
    - you don't need to read the whole documentation of this page

















<div style="page-break-after: always;"></div>

## Chapter 3: Common Patterns: _if someone missed to catch it yet_ üòâ
```ruby
Object  Vk      VkInstance
Types   Vk      VkInstanceCreateInfo
Funcs   vk      vkCreateInstance()
Enums   VK_     VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO

Extensions
    KHR:- Khronos authored,
    EXT:- multi-company authored

Creating "VkZZZ" object
    1. take `VkZZZCreateInfo` --> fill it up
    2. call `vkCreateZZZ()`
    3. also `vkDestroyZZZ()` before closing your app

    4. Some objects get "allocated" rather than "created"
        `VkZZZAllocateInfo` --> `vkAllocateZZZ` --> `vkFreeZZZ`

    5. Sometimes there will be `.zzzCreateInfoCount` & `.pZZZCreateInfos`
                        e.g. `.queueCreateInfoCount` & `.pQueueCreateInfos``
            -> So you could like pass in an array/vector
            -> You will see this in lots of other places

Getting List/Properties
    1. vkEnumerateZZZ() --> \see `[Chapter2.1.] vkEnumeratePhysicalDevices()` example
```
-- | -- | -- | ----------------------------------------------------------------------------

7. `sType` & `pNext`
    - Many Vulkan structures include these two common fields
8. `sType`:-
    - It may seem somewhat redundant, but this information can be useful for the `vulkan-loader` and actual `gpu-driver-implementations` to know what type of structure was passed in through `pNext`.
9. `pNext`:-
    - _allows to create a linked list between structures._
    - It is mostly used when dealing with extensions that expose new structures to provide additional information to the `vulkan-loader`, `debugging-validation-layers`, and `gpu-driver-implementations`.
        - _i.e. they can use the `pNext->stype` field to know what's ahead in the linked list_

-- | -- | -- | ----------------------------------------------------------------------------
```ruby
10. Do remember to check the `Valid Usage` section within each manual-page
```

##### Two Questions I keep on pondering ü§î
    - a) Would this make sense to someone else?
    - b) Would this make sense to a 5 year old?